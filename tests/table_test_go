package tests

import (
	. "github.com/ionous/sashimi/script"
	"github.com/ionous/sashimi/standard"
	"github.com/ionous/sashimi/util/ident"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"testing"
)

func makeSweets(s *Script) {
	s.The("kinds",
		Called("sweets"),
		Have("desc", "text"),
		Have("price", "num"),
		AreOneOf("delicious", "decent", "acceptable", "you can't be serious"))
}
func nameSweets(s *Script) {
	s.The("sweets",
		Table("name", "desc", "delicious"). //-property
							Has("Boreo", "Creme filled wafer things.", "acceptable").
							And("Vegan chocolate chip cookies", "The secret is the bacon... err... baking.", "delicious").
							And("Sugar coated ants", "A crunchy summer's day snack.", "you can't be serious"),
	)
}

// 1. create a simple table declaration and generate some fixed instances
func TestTableDecl(t *testing.T) {
	s := &Script{}
	makeSweets(s)
	nameSweets(s)
	if res, err := s.Compile(Log(t)); assert.NoError(t, err, "table compile") {
		m := res.Model
		require.Len(t, m.Instances, 3)
		// and now some values:
		if inst, ok := m.Instances[ident.MakeId("boreo")]; assert.True(t, ok, "find tabled instance by name") {
			desc := ident.MakeId("sweets-desc")
			//
			if val, ok := inst.Values[desc]; assert.True(t, ok, "find desc") {
				if str, ok := val.(string); assert.True(t, ok, "have string") {
					assert.EqualValues(t, str, "Creme filled wafer things.")
				}
			}
			//
			if cls, ok := m.Classes[inst.Class]; assert.True(t, ok, "found class") {
				//-property
				if prop, ok := cls.FindProperty("delicious"); assert.True(t, ok, "find deliciousness") {
					if val, ok := inst.Values[prop.Id]; assert.True(t, ok, "find value") {
						if _, ok := m.Enumerations[prop.Id]; assert.True(t, ok, "found enum") {
							//val := enum.IndexToChoice(val.(int))
							assert.EqualValues(t, val, ident.MakeId("acceptable"))
						}
					}
				}
			}
		}
	}
}

// 2. create a simple table declaration with autogenerated instances
func TestTableGeneration(t *testing.T) {
	s := &Script{}
	makeSweets(s)
	s.The("sweets",
		Table("desc", "delicious").Has( //-property
			"Creme filled wafer things.", "acceptable").And(
			"It looks the way poisonous berries smell.", "delicious").And(
			"A crunchy summer's day snack.", "you can't be serious",
		),
	)
	if res, err := s.Compile(Log(t)); assert.NoError(t, err, "table compile") {
		m := res.Model
		assert.Len(t, m.Instances, 3)
	}
}

// 3. merge some non-contrary instance data
func TestTabledData(t *testing.T) {
	s := &Script{}
	makeSweets(s)
	nameSweets(s)
	s.Our("Boreo", Is("acceptable"), Has("price", 42))
	if res, err := s.Compile(Log(t)); assert.NoError(t, err, "table compile") {
		m := res.Model
		if inst, ok := m.Instances[ident.MakeId("boreo")]; assert.True(t, ok, "find tabled instance by name") {
			price := ident.MakeId("sweets-price")
			if val, ok := inst.Values[price]; assert.True(t, ok, "find desc") {
				assert.EqualValues(t, 42, val)
			}
		}
	}
}

func makePeople(s *Script) *Script {
	s.The("kinds", Called("objects"), Exist())
	s.The("objects",
		Called("actors"),
		Have("favorite sweet", "sweet"))
	return s
}

func namePeople(s *Script) {
	s.The("actors",
		Table("name", "favorite sweet").Has(
			"Marvin", "Sugar coated ants").And(
			"Allen", "Boreo").And(
			"Grace", "Vegan chocolate chip cookies",
		),
	)
}

// 4. test table declarations which use pointers
func TestTablePointers(t *testing.T) {
	s := &Script{}
	makeSweets(s)
	nameSweets(s)
	makePeople(s)
	namePeople(s)
	if res, err := s.Compile(Log(t)); assert.NoError(t, err, "table compile") {
		m := res.Model
		if inst, ok := m.Instances[ident.MakeId("Grace")]; assert.True(t, ok, "find person by name") {
			fav := ident.MakeId("actors favorite sweet")
			if val, ok := inst.Values[fav]; assert.True(t, ok, "find favorite") {
				if id, ok := val.(ident.Id); assert.True(t, ok, "id") {
					assert.EqualValues(t, id, ident.MakeId("VeganChocolateChipCookies"))
				}
			}
		}
	}
}

// 5. test runtime instance usage which use pointers
func TestTableRuntime(t *testing.T) {
	s := standard.InitStandardLibrary()
	makeSweets(s)
	nameSweets(s)
	makePeople(s)
	namePeople(s)
	if test, err := NewTestGame(t, s); assert.NoError(t, err) {
		//test.Model.PrintModel(t.Log)
		g := test.Game.NewAdapter()
		if grace := g.Our("Grace"); assert.True(t, grace.Exists()) {
			if sweet := grace.Object("favorite sweet"); assert.True(t, sweet.Exists(), "grace should have a treat") {
				if boreo := g.The("Boreo"); assert.True(t, boreo.Exists()) {
					grace.Set("favorite sweet", boreo)
					retread := grace.Object("favorite sweet").Text("name")
					assert.Equal(t, "Boreo", retread)
				}
			}
		}
	}
}
