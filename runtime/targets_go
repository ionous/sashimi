targets_go


//
// func (this ObjectTarget) Events() (E.IDispatch, bool) {
// 	return this.game.Dispatchers.GetOrNil(this.obj.info)
// }

//
// ClassTarget
//
// originally, the targets constructed a uniform chain of objects and classes
// however, what we actually want is that classes act as a "shortcut" for adding handlers to objects
// not actually act as handlers themselves -- then, we can have "current target; target phase" rules
// which apply to the object, even though they are added to the class associated with the object
// for instance: the container class can print its description when the object is targeted directly,
// but not if it's simply hearing the event that an item in the container is printing its description
//
//

//
// Retrieve the dispatcher for the passed key, only if it exists.
//
func (this Dispatchers) GetDispatcher(key interface{}) (E.IDispatch, bool) {
	dispatcher, ok := this.all[key]
	// if !ok {
	// 	dispatcher = NilDispatch(this)
	// }
	return dispatcher, ok
}

// type NilDispatch Dispatchers
// func (NilDispatch) Listen(string, E.IListen, bool)  {}
// func (NilDispatch) Silence(string, E.IListen, bool) {}
// func (NilDispatch) Clear()                          {}
// func (NilDispatch) Dispatch(E.IEvent) error         { return nil }
